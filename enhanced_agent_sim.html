<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Agent World Simulation</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: #fff;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .controls-section {
            display: flex;
            gap: 10px;
            padding: 10px;
            border: 1px solid #555;
            border-radius: 4px;
            margin-bottom: 10px;
        }
        
        .controls-section h4 {
            margin: 0 10px 0 0;
            color: #ccc;
        }
        
        button {
            padding: 8px 16px;
            background: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
        }
        
        button:hover {
            background: #444;
        }
        
        button:disabled {
            background: #222;
            cursor: not-allowed;
        }
        
        .slider-control {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .slider-control label {
            font-size: 12px;
        }
        
        .slider-control input[type="range"] {
            width: 100px;
        }
        
        .info {
            margin-bottom: 20px;
            font-size: 14px;
            color: #ccc;
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .time-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .sun-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: radial-gradient(circle, #FFD700, #FFA500);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        
        .moon-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: radial-gradient(circle, #E6E6FA, #C0C0C0);
            box-shadow: 0 0 10px rgba(230, 230, 250, 0.3);
        }
        
        #canvas {
            border: 2px solid #555;
            background: #000;
            cursor: crosshair;
        }
        
        .legend {
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .color-box {
            width: 20px;
            height: 20px;
            border: 1px solid #555;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Enhanced Agent World Simulation</h1>
        
        <div class="controls-section">
            <h4>Simulation:</h4>
            <button onclick="toggleSimulation()">Start/Stop</button>
            <button onclick="stepSimulation()">Step</button>
            <button onclick="resetWorld()">Reset</button>
            <button onclick="addRandomAgent()">Add Agent</button>
            <button onclick="saveState()">Save State</button>
            <button onclick="loadState()">Load State</button>
            <div class="slider-control">
                <label>Speed:</label>
                <input type="range" id="speedSlider" min="1" max="10" value="5" onchange="updateSpeed()">
            </div>
        </div>
        
        <div class="controls-section">
            <h4>Environment:</h4>
            <div class="slider-control">
                <label>Grass Growth Rate:</label>
                <input type="range" id="grassGrowthSlider" min="1" max="10" value="5" onchange="updateGrassGrowth()">
                <span id="grassGrowthValue">5</span>
            </div>
            <div class="slider-control">
                <label>Cloud Speed:</label>
                <input type="range" id="cloudSpeedSlider" min="0" max="10" value="3" onchange="updateCloudSpeed()">
                <span id="cloudSpeedValue">3</span>
            </div>
            <div class="slider-control">
                <label>Cloud Density:</label>
                <input type="range" id="cloudDensitySlider" min="0" max="10" value="5" onchange="updateCloudDensity()">
                <span id="cloudDensityValue">5</span>
            </div>
        </div>
        
        <div class="info">
            <span>Agents: <span id="agentCount">0</span></span>
            <span>Step: <span id="stepCount">0</span></span>
            <span>Status: <span id="status">Stopped</span></span>
            <div class="time-info">
                <span id="timeIcon" class="sun-icon"></span>
                <span>Time: <span id="timeDisplay">Day 1, 06:00</span></span>
            </div>
        </div>
        
        <canvas id="canvas" width="800" height="600"></canvas>
        
        <div class="legend">
            <div class="legend-item">
                <div class="color-box" style="background: #654321;"></div>
                <span>Ground</span>
            </div>
            <div class="legend-item">
                <div class="color-box" style="background: #228B22;"></div>
                <span>Fresh Grass</span>
            </div>
            <div class="legend-item">
                <div class="color-box" style="background: #8B4513;"></div>
                <span>Eaten Grass</span>
            </div>
            <div class="legend-item">
                <div class="color-box" style="background: #4169E1;"></div>
                <span>Water</span>
            </div>
            <div class="legend-item">
                <div class="color-box" style="background: #228B22; border: 2px solid #8B4513;"></div>
                <span>Tree</span>
            </div>
            <div class="legend-item">
                <div class="color-box" style="background: #FF0000;"></div>
                <span>Agent (Active)</span>
            </div>
            <div class="legend-item">
                <div class="color-box" style="background: #6666FF;"></div>
                <span>Agent (Passive)</span>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const TILE_SIZE = 20;
        const WORLD_WIDTH = Math.floor(canvas.width / TILE_SIZE);
        const WORLD_HEIGHT = Math.floor(canvas.height / TILE_SIZE);
        
        // Tile types
        const TILES = {
            GROUND: 0,
            GRASS_FRESH: 1,
            GRASS_EATEN: 2,
            WATER: 3,
            TREE: 4
        };
        
        const TILE_COLORS = {
            [TILES.GROUND]: '#654321',
            [TILES.GRASS_FRESH]: '#228B22',
            [TILES.GRASS_EATEN]: '#8B4513',
            [TILES.WATER]: '#4169E1',
            [TILES.TREE]: '#228B22'
        };
        
        // Simulation parameters
        let grassGrowthRate = 5;
        let cloudSpeed = 3;
        let cloudDensity = 5;
        
        // Time system
        let gameTime = 0;
        let dayCount = 1;
        const DAY_LENGTH = 24;
        
        // Cloud system
        let cloudField = [];
        let cloudVelocityX = [];
        let cloudVelocityY = [];
        
        // Simulation state
        let world = [];
        let grassGrowthTimers = [];
        let agents = [];
        let isRunning = false;
        let stepCount = 0;
        let animationSpeed = 200;
        let intervalId = null;
        
        // Agent class with personality parameters
        class Agent {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.energy = 100;
                this.maxEnergy = 100;
                this.direction = Math.floor(Math.random() * 4);
                this.id = Math.random().toString(36).substr(2, 9);
                
                // Personality parameters
                this.versatility = Math.random() * 0.8 + 0.1; // 0.1-0.9: how often they change direction
                this.activation = Math.random() * 0.8 + 0.1; // 0.1-0.9: how often they move
                this.explorationRadius = Math.floor(Math.random() * 3) + 1; // 1-3: how far they look for grass
                
                this.memory = new Map();
                this.lastMoved = 0;
                this.idleSteps = 0;
            }
            
            update() {
                // Movement decision based on activation level
                const baseMoveProbability = this.activation * 0.6;
                const hungerBonus = this.energy < 50 ? 0.3 : 0;
                const moveProbability = Math.min(0.9, baseMoveProbability + hungerBonus);
                
                if (Math.random() < moveProbability) {
                    // Direction change based on versatility
                    if (Math.random() < this.versatility) {
                        if (this.energy < 70) {
                            this.seekGrass();
                        } else {
                            this.direction = Math.floor(Math.random() * 4);
                        }
                    }
                    
                    this.move();
                    this.idleSteps = 0;
                } else {
                    this.idleSteps++;
                }
                
                this.interactWithTile();
                this.updateEnergy();
            }
            
            seekGrass() {
                let bestDirection = this.direction;
                let bestDistance = Infinity;
                
                // Search in expanding radius based on exploration parameter
                for (let radius = 1; radius <= this.explorationRadius; radius++) {
                    for (let dir = 0; dir < 4; dir++) {
                        const [targetX, targetY] = this.getPositionInDirection(dir, radius);
                        
                        if (this.isValidPosition(targetX, targetY) && world[targetY][targetX] === TILES.GRASS_FRESH) {
                            const distance = Math.abs(targetX - this.x) + Math.abs(targetY - this.y);
                            if (distance < bestDistance) {
                                bestDistance = distance;
                                bestDirection = dir;
                            }
                        }
                    }
                    
                    if (bestDistance < Infinity) break;
                }
                
                if (bestDistance < Infinity) {
                    this.direction = bestDirection;
                } else {
                    // No grass found, random movement with high versatility
                    this.direction = Math.floor(Math.random() * 4);
                }
            }
            
            getPositionInDirection(direction, distance) {
                let x = this.x;
                let y = this.y;
                
                switch(direction) {
                    case 0: y -= distance; break;
                    case 1: x += distance; break;
                    case 2: y += distance; break;
                    case 3: x -= distance; break;
                }
                
                return [x, y];
            }
            
            getNextPosition(direction) {
                return this.getPositionInDirection(direction, 1);
            }
            
            move() {
                const [newX, newY] = this.getNextPosition(this.direction);
                
                if (this.canMoveTo(newX, newY)) {
                    this.x = newX;
                    this.y = newY;
                    this.lastMoved = stepCount;
                }
            }
            
            canMoveTo(x, y) {
                return this.isValidPosition(x, y) && this.isPassableTile(world[y][x]);
            }
            
            isValidPosition(x, y) {
                return x >= 0 && x < WORLD_WIDTH && y >= 0 && y < WORLD_HEIGHT;
            }
            
            isPassableTile(tile) {
                return tile !== TILES.WATER && tile !== TILES.TREE;
            }
            
            interactWithTile() {
                const currentTile = world[this.y][this.x];
                
                if (currentTile === TILES.GRASS_FRESH) {
                    this.energy = Math.min(this.maxEnergy, this.energy + 15);
                    world[this.y][this.x] = TILES.GRASS_EATEN;
                    grassGrowthTimers[this.y][this.x] = stepCount + this.getGrassRegrowthTime();
                }
            }
            
            getGrassRegrowthTime() {
                const baseTime = 60 - (grassGrowthRate * 5);
                return Math.floor(Math.random() * 20) + Math.max(10, baseTime);
            }
            
            updateEnergy() {
                // Energy consumption varies with activation level
                const energyCost = 0.3 + (this.activation * 0.4);
                this.energy -= energyCost;
                
                if (this.energy < 0) this.energy = 0;
                if (this.energy > this.maxEnergy) this.energy = this.maxEnergy;
            }
            
            getColor() {
                // Color based on activation level and energy
                const isActive = this.activation > 0.5;
                
                if (this.energy < 30) {
                    return isActive ? '#FF3333' : '#9933FF';
                } else if (this.energy < 60) {
                    return isActive ? '#FF6666' : '#6666FF';
                } else {
                    return isActive ? '#FF0000' : '#3333FF';
                }
            }
        }
        
        // Cloud system
        function initClouds() {
            cloudField = [];
            cloudVelocityX = [];
            cloudVelocityY = [];
            
            for (let y = 0; y < WORLD_HEIGHT; y++) {
                cloudField[y] = [];
                cloudVelocityX[y] = [];
                cloudVelocityY[y] = [];
                for (let x = 0; x < WORLD_WIDTH; x++) {
                    cloudField[y][x] = Math.random() * (cloudDensity / 10);
                    cloudVelocityX[y][x] = (Math.random() - 0.5) * 0.1;
                    cloudVelocityY[y][x] = (Math.random() - 0.5) * 0.1;
                }
            }
        }
        
        function updateClouds() {
            if (cloudSpeed === 0) return;
            
            const speed = cloudSpeed / 100;
            const newCloudField = [];
            
            // Simple fluid dynamics approximation
            for (let y = 0; y < WORLD_HEIGHT; y++) {
                newCloudField[y] = [];
                for (let x = 0; x < WORLD_WIDTH; x++) {
                    let avgCloud = cloudField[y][x];
                    let count = 1;
                    
                    // Average with neighbors
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const nx = x + dx;
                            const ny = y + dy;
                            if (nx >= 0 && nx < WORLD_WIDTH && ny >= 0 && ny < WORLD_HEIGHT) {
                                avgCloud += cloudField[ny][nx];
                                count++;
                            }
                        }
                    }
                    
                    avgCloud /= count;
                    
                    // Add flow
                    const flowX = cloudVelocityX[y][x] * speed;
                    const flowY = cloudVelocityY[y][x] * speed;
                    
                    newCloudField[y][x] = Math.max(0, Math.min(1, avgCloud + (Math.random() - 0.5) * 0.01));
                    
                    // Update velocities
                    cloudVelocityX[y][x] += (Math.random() - 0.5) * 0.02;
                    cloudVelocityY[y][x] += (Math.random() - 0.5) * 0.02;
                    
                    // Damping
                    cloudVelocityX[y][x] *= 0.98;
                    cloudVelocityY[y][x] *= 0.98;
                }
            }
            
            cloudField = newCloudField;
        }
        
        function getCloudShadow(x, y) {
            if (x < 0 || x >= WORLD_WIDTH || y < 0 || y >= WORLD_HEIGHT) return 0;
            return cloudField[y][x] * 0.5; // Clouds reduce light by up to 50%
        }
        
        // Time management
        function updateTime() {
            gameTime = (stepCount % (DAY_LENGTH * 4)) / 4;
            dayCount = Math.floor(stepCount / (DAY_LENGTH * 4)) + 1;
            
            const hours = Math.floor(gameTime);
            const minutes = Math.floor((gameTime - hours) * 60);
            
            const timeString = `Day ${dayCount}, ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
            document.getElementById('timeDisplay').textContent = timeString;
            
            const timeIcon = document.getElementById('timeIcon');
            if (hours >= 6 && hours < 18) {
                timeIcon.className = 'sun-icon';
            } else {
                timeIcon.className = 'moon-icon';
            }
        }
        
        function isDaytime() {
            const hours = Math.floor(gameTime);
            return hours >= 6 && hours < 18;
        }
        
        // World management
        function initWorld() {
            world = [];
            grassGrowthTimers = [];
            
            for (let y = 0; y < WORLD_HEIGHT; y++) {
                world[y] = [];
                grassGrowthTimers[y] = [];
                for (let x = 0; x < WORLD_WIDTH; x++) {
                    let tile = TILES.GROUND;
                    const rand = Math.random();
                    
                    if (rand < 0.4) tile = TILES.GRASS_FRESH;
                    else if (rand < 0.5) tile = TILES.WATER;
                    else if (rand < 0.6) tile = TILES.TREE;
                    
                    world[y][x] = tile;
                    grassGrowthTimers[y][x] = 0;
                }
            }
            
            initClouds();
        }
        
        function updateGrassGrowth() {
            const growthBonus = isDaytime() ? 1 : 0;
            
            for (let y = 0; y < WORLD_HEIGHT; y++) {
                for (let x = 0; x < WORLD_WIDTH; x++) {
                    if (world[y][x] === TILES.GRASS_EATEN && grassGrowthTimers[y][x] > 0) {
                        // Light affects growth rate
                        const cloudShadow = getCloudShadow(x, y);
                        const lightBonus = isDaytime() ? (1 - cloudShadow) : 0.2;
                        const totalBonus = Math.floor(growthBonus * lightBonus);
                        
                        if (stepCount >= grassGrowthTimers[y][x] - totalBonus) {
                            world[y][x] = TILES.GRASS_FRESH;
                            grassGrowthTimers[y][x] = 0;
                        }
                    }
                }
            }
        }
        
        // Rendering
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const baseLightLevel = isDaytime() ? 1.0 : 0.6;
            
            // Draw tiles with cloud shadows
            for (let y = 0; y < WORLD_HEIGHT; y++) {
                for (let x = 0; x < WORLD_WIDTH; x++) {
                    const tile = world[y][x];
                    let color = TILE_COLORS[tile];
                    
                    // Apply day/night and cloud lighting
                    const cloudShadow = getCloudShadow(x, y);
                    const lightLevel = baseLightLevel * (1 - cloudShadow);
                    
                    if (lightLevel < 1.0) {
                        const rgb = hexToRgb(color);
                        color = `rgb(${Math.floor(rgb.r * lightLevel)}, ${Math.floor(rgb.g * lightLevel)}, ${Math.floor(rgb.b * lightLevel)})`;
                    }
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    
                    // Draw tree trunks
                    if (tile === TILES.TREE) {
                        let trunkColor = '#8B4513';
                        if (lightLevel < 1.0) {
                            const rgb = hexToRgb(trunkColor);
                            trunkColor = `rgb(${Math.floor(rgb.r * lightLevel)}, ${Math.floor(rgb.g * lightLevel)}, ${Math.floor(rgb.b * lightLevel)})`;
                        }
                        ctx.fillStyle = trunkColor;
                        ctx.fillRect(x * TILE_SIZE + 6, y * TILE_SIZE + 10, 8, 10);
                    }
                    
                    // Draw cloud overlay
                    if (cloudShadow > 0.1) {
                        ctx.fillStyle = `rgba(200, 200, 200, ${cloudShadow * 0.3})`;
                        ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                }
            }
            
            // Draw grid
            ctx.strokeStyle = isDaytime() ? '#333' : '#222';
            ctx.lineWidth = 0.5;
            for (let x = 0; x <= WORLD_WIDTH; x++) {
                ctx.beginPath();
                ctx.moveTo(x * TILE_SIZE, 0);
                ctx.lineTo(x * TILE_SIZE, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= WORLD_HEIGHT; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * TILE_SIZE);
                ctx.lineTo(canvas.width, y * TILE_SIZE);
                ctx.stroke();
            }
            
            // Draw agents
            agents.forEach(agent => {
                const cloudShadow = getCloudShadow(agent.x, agent.y);
                const lightLevel = baseLightLevel * (1 - cloudShadow);
                let agentColor = agent.getColor();
                
                if (lightLevel < 1.0) {
                    const rgb = hexToRgb(agentColor);
                    agentColor = `rgb(${Math.floor(rgb.r * lightLevel)}, ${Math.floor(rgb.g * lightLevel)}, ${Math.floor(rgb.b * lightLevel)})`;
                }
                
                ctx.fillStyle = agentColor;
                ctx.fillRect(
                    agent.x * TILE_SIZE + 2, 
                    agent.y * TILE_SIZE + 2, 
                    TILE_SIZE - 4, 
                    TILE_SIZE - 4
                );
                
                // Draw energy bar
                const energyWidth = (TILE_SIZE - 6) * (agent.energy / agent.maxEnergy);
                const energyColor = agent.energy > 60 ? '#00FF00' : agent.energy > 30 ? '#FFFF00' : '#FF0000';
                ctx.fillStyle = energyColor;
                ctx.fillRect(
                    agent.x * TILE_SIZE + 3,
                    agent.y * TILE_SIZE + 3,
                    energyWidth,
                    2
                );
                
                // Draw activation indicator (small dot)
                ctx.fillStyle = agent.activation > 0.5 ? '#FFFFFF' : '#666666';
                ctx.fillRect(
                    agent.x * TILE_SIZE + TILE_SIZE - 6,
                    agent.y * TILE_SIZE + 2,
                    2, 2
                );
            });
            
            updateUI();
        }
        
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }
        
        // Parameter controls
        function updateGrassGrowth() {
            const slider = document.getElementById('grassGrowthSlider');
            grassGrowthRate = parseInt(slider.value);
            document.getElementById('grassGrowthValue').textContent = grassGrowthRate;
        }
        
        function updateCloudSpeed() {
            const slider = document.getElementById('cloudSpeedSlider');
            cloudSpeed = parseInt(slider.value);
            document.getElementById('cloudSpeedValue').textContent = cloudSpeed;
        }
        
        function updateCloudDensity() {
            const slider = document.getElementById('cloudDensitySlider');
            cloudDensity = parseInt(slider.value);
            document.getElementById('cloudDensityValue').textContent = cloudDensity;
            initClouds(); // Reinitialize clouds with new density
        }
        
        // Simulation control
        function toggleSimulation() {
            if (isRunning) {
                stopSimulation();
            } else {
                startSimulation();
            }
        }
        
        function startSimulation() {
            isRunning = true;
            intervalId = setInterval(stepSimulation, animationSpeed);
            document.getElementById('status').textContent = 'Running';
        }
        
        function stopSimulation() {
            isRunning = false;
            if (intervalId) {
                clearInterval(intervalId);
                intervalId = null;
            }
            document.getElementById('status').textContent = 'Stopped';
        }
        
        function stepSimulation() {
            agents.forEach(agent => agent.update());
            updateGrassGrowth();
            updateClouds();
            updateTime();
            stepCount++;
            render();
        }
        
        function resetWorld() {
            stopSimulation();
            initWorld();
            agents = [];
            stepCount = 0;
            gameTime = 0;
            dayCount = 1;
            render();
        }
        
        function addRandomAgent() {
            let x, y;
            let attempts = 0;
            do {
                x = Math.floor(Math.random() * WORLD_WIDTH);
                y = Math.floor(Math.random() * WORLD_HEIGHT);
                attempts++;
            } while ((world[y][x] === TILES.WATER || world[y][x] === TILES.TREE) && attempts < 100);
            
            if (attempts < 100) {
                agents.push(new Agent(x, y));
                render();
            }
        }
        
        function updateSpeed() {
            const slider = document.getElementById('speedSlider');
            animationSpeed = 1100 - (slider.value * 100);
            if (isRunning) {
                stopSimulation();
                startSimulation();
            }
        }
        
        function updateUI() {
            document.getElementById('agentCount').textContent = agents.length;
            document.getElementById('stepCount').textContent = stepCount;
        }
        
        // Save/Load functionality
        function saveState() {
            const state = {
                world: world,
                grassGrowthTimers: grassGrowthTimers,
                cloudField: cloudField,
                agents: agents.map(agent => ({
                    x: agent.x,
                    y: agent.y,
                    energy: agent.energy,
                    maxEnergy: agent.maxEnergy,
                    direction: agent.direction,
                    id: agent.id,
                    versatility: agent.versatility,
                    activation: agent.activation,
                    explorationRadius: agent.explorationRadius,
                    lastMoved: agent.lastMoved,
                    idleSteps: agent.idleSteps
                })),
                stepCount: stepCount,
                gameTime: gameTime,
                dayCount: dayCount,
                grassGrowthRate: grassGrowthRate,
                cloudSpeed: cloudSpeed,
                cloudDensity: cloudDensity
            };
            
            const stateStr = JSON.stringify(state);
            const blob = new Blob([stateStr], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `simulation_state_${Date.now()}.json`;
            a.click();
            
            URL.revokeObjectURL(url);
        }
        
        function loadState() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const state = JSON.parse(e.target.result);
                            
                            world = state.world;
                            grassGrowthTimers = state.grassGrowthTimers || [];
                            cloudField = state.cloudField || [];
                            agents = state.agents.map(agentData => {
				const agent = new Agent(agentData.x, agentData.y);
                                agent.energy = agentData.energy;
                                agent.direction = agentData.direction;
                                agent.id = agentData.id;
                                return agent;
                            });
                            stepCount = state.stepCount || 0;
                            
                            render();
                        } catch (error) {
                            alert('Error loading state: ' + error.message);
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }
        
        // Canvas click handler for manual tile editing
        canvas.addEventListener('click', function(e) {
            if (isRunning) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / TILE_SIZE);
            const y = Math.floor((e.clientY - rect.top) / TILE_SIZE);
            
            if (x >= 0 && x < WORLD_WIDTH && y >= 0 && y < WORLD_HEIGHT) {
                // Cycle through tile types
                world[y][x] = (world[y][x] + 1) % Object.keys(TILES).length;
                render();
            }
        });
        
        // Initialize
        initWorld();
        render();
        
        // Add some initial agents
        for (let i = 0; i < 3; i++) {
            addRandomAgent();
        }
    </script>
</body>
</html>
